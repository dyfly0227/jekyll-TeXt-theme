---
title: Vue面试题
excerpt: 无可避免的Vue面试题
tags: ['vue','面试']
---

## Vue Seo
1. 预渲染
    * vue插件：`prerender-spa-plugin`
    * 解决title,描述,关键词插件：`vue-meta-info`
    * 打包结果：会有多个html页面
    * 缺点：
        1. 需要对每个路由进行配置，不适合多个页面seo
        2. 如果seo的内容来自于接口(即动态数据)则不能生效
    * 优点：
        仅需要几个页面做seo
2. 服务器渲染(Nuxt.js)
    项目上线流程
     1. `npm run build`
     2. 将打包完成的文件单独拷贝出来
     3. 将四个文件`nuxt.config/.nuxt/package.json/static`放在服务器上，服务器安装node环境
     4. `npm install`
     5. `npm run start`
     6. `nginx`设置代理

## Webpack性能优化
    1. 优化构建速度
        1. 升级新版本
        2. 优化搜索文件
            1. 缩小文件的搜索范围（合理使用resolve功能，resolve.alias/配置loader时，使用exclude,include）
            2. 使用module.noParse告诉webpack不必解析哪些文件
        3. 通过Dllplugin和ReferencePlugin避免重复编译第三方库
        4. 使用HappyPack开启多进程Loader转换
        5. 使用ParalleUgifyPlugin多进程压缩JS文件
    2. 优化开发体验
        开启热更替HMR

        > 模块热更新不刷新整个网页只重新编译发生变化的模块，并用新模块替换老模块

    3. 优化输出质量——压缩文件体积
        1. 通过DefinePlugin区分环境
        2. 压缩资源
        3. 使用Tree Shaking剔除无用代码
        4. gzip压缩
        5. 第三方库用cdn引入

## Vue2和Vue3的区别
    1. 双向绑定的原理发生了变化

        > Object.defineProperty对于数组拦截有问题，且需要深度递归遍历才能对对象完全拦截
        proxy不仅可以对数组拦截，还能对Map,set实现拦截，另外Proxy的拦截是懒处理行为，如果用户没有访问嵌套对象，那么不会实现拦截，这就让初始化的速度和内存占比都改善

    2. Vue3支持碎片，即可以在组件中放置多个根节点
    3. Vue3采用Composition Api, Vue2使用Option Api
    4. 建立数据的方式
    5. 生命周期钩子函数
    6. 父子传参方式不同
    7. Vue3新增了Teleport瞬移组件

## Vue组件扩展
在设计组件时，希望它越小越好，功能越专注越好，但是适用场景较小，此时就需要对它就行扩展，即高阶组件。

    * 常见的组件扩展方式：mixins,slots,extends
        1. mixins比较混乱，有全局有局部的，容易冲突
        2. slots适用于容器型组件
        3. extends用于继承组件的基础上再扩展
    * Vue3的Composition Api

## 首屏优化
    1. 使用路由懒加载
    2. 非首屏组件使用异步组件
    3. 不重要的组件延迟加载
    4. 静态资源放在CDN上
    5. 减少首屏上JS,CSS等资源文件的大小
    6. 做一些loading
    7. 图片懒加载

## 父子组件传值
    1. props + emit
    2. 回调函数
    3. 通过`$parent`和`$children`访问组件实例
    4. provide + inject
    5. $attrs可以传递绑定的属性，$listeners可以传递绑定的方法
    6. 通过ref获取组件实例

## Vue错误捕获

1. 使用**errorCaptured**钩子

    > 当组件出错后，错误会一直向上抛，但是如果当前组件errorCaptured中返回false则会阻断传播

2. 全局设置错误处理
    ```javascript
    Vue.config.errorHandler = (err, vm, info) => {}
    ```

## diff算法
1. 只比较同一层级，不跨级比较
2. 标签名不同，直接删除，不继续深度比较
3. 标签名相同，key相同，就认为是相同节点，不继续深度比较
