---
title: 面试-vue
excerpt: 无可避免的Vue面试题
tags: ['vue','面试']
---

## 路由参数
* `query`要用`path`引入，参数会显示在`URL`上，获取用`this.$route.query`
* `params`要用`name`引入，获取用`this.$route.params`

## 常用修饰符
- `.stop` 阻止冒泡
- `.prevent` 阻止默认行为
- `.capture` 阻止捕获
- `.once` 只触发一次

## nextTick
原理就是生成一个微任务或者延迟宏任务插入任务队列，保证在同一事件循环后执行
优先级（浏览器支持情况不同）：**Promise > MutationObserver > setImmediate > setTimeout**

## VueX
> 采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生改变

**原理**：通过vue的`mixin`机制，借助vue组件的生命周期钩子`beforeCreate`注入`store`对象。即每个vue组件实例化过程中，会在`beforeCreate`钩子前调用`vuexInit`方法。
**使用方式**：
- `this.$store.state.*` | `mapstate` 获取属性
- `this.$store.getters.*`|`mapGetters` 获取属性getter
- `this.$store.dispath()` | `mapActions` 触发action
- `this.$store.commit()` | `mapMutations` 触发mutation

> action里面是可以执行异步操作的，它返回的是一个Promise，所以可以使用store.dispath().then()

## Vue Router

**工作流程**：
- url改变：`location.hash` | `history.pushState | history.replaceState`
- 触发监听事件：`onhashchange` | `onpopstate`
- 改变vue-router里面的current变量
- 监视currrent变量
- 获取对应的组件
- render新组件

**hash和history的区别**：
- pushState设置新的url可以使与当前url同源的任意url，hash只修改#后面的部分
- pushState设置的新url可以与当前一模一样，这样也会把记录添加到栈里，而hash设置的新值必须与原来不一样
- history刷新必须后端的配合
- pushState可以额外设置`title`属性

**路由钩子**：
- 【全局守卫】`router.beforeEach(to, from, next) `：可以定义多个
- 【全局守卫】`router.beforeResolve(to,from,next)`： 所有**组件内守卫**和**异步路由组件**被解析之后触发
- 【全局守卫】`router.afterEach(to, from)`：没有next，不会改变导航本身
- 【路由守卫】`beforeEnter(to,from,next)`
- 【组件守卫】`beforeRouteEnter(to,from,next)`: this不可用，在`beforeCreate`之前，不过可以通过`next(vm=>{})`的方式
- 【组件守卫】`beforeRouteUpdate(to,from)`：组件被复用时调用
- 【组件守卫】`beforeRouteLeave(to,from)`：可以访问this

**滚动行为**：
```javascript
const router = createRouter({
	scrollBehavior(to,from,savedPosition) {
		return {top:0}
	}
})
```
**优化策略**：
- 路由懒加载
- 把组件按组分块（注释语法来提供chunk name）

**动态路由**：`router.addRoute|removeRoute`


## 双向数据绑定
首先，总共有个4个模块
    1. `Observer`用于数据劫持，核心方法`get()`和`set()`
    2. `Dep`订阅者容器，和兴方法`addSub()`和`notify()`
    3. `Compile`用于解析模板
    4. `Watcher`充当一个桥梁的角色，核心方法`update()`
具体过程如下：
    1. `Observe`劫持`data`,让`data`中的每一个属性都有对应的`get()`和`set()`
    2. `Compile`解析模板，找到对应的属性，然后执行`new Watcher()`将自身以及更新函数传给`Watcher`
    3. 在`Watcher`的构造函数中，先将`Compile`传过来的更新函数赋予`this.callback`，接着将一个全局对象`Dep.temp`指向`this`，然后触发`Observer`的`get()`,紧接着设置`Dep.temp=null`防止多次订阅。
    4. `Observer`的`get()`会判断`Dep.temp`是否存在，存在则调用`Dep`实例对象的`addSub()`将其订阅
    5. 之后一旦数据发生变动触发`Observe`的`set()`方法，`set()`会执行`Dep`实例对象的`notify()`，执行`Watcher`的`update()`方法
    6. 之后执行`patch`方法执行`diff算法`
   
## patchVnode的规则
1. 新老节点均有`children`子节点，则对子节点执行`diff算法`，调用`updateChildren()`
2. 新节点有子节点，而旧节点没有，则先清空旧节点的内容，然后为其新增子节点
3. 如果新节点没有子节点，而旧节点有，则移除该节点的所有子节点
4. 当新旧节点都没有子节点时，则仅是文本的替换

## Vue Seo
1. 预渲染
    * vue插件：`prerender-spa-plugin`
    * 解决title,描述,关键词插件：`vue-meta-info`
    * 打包结果：会有多个html页面
    * 缺点：
        1. 需要对每个路由进行配置，不适合多个页面seo
        2. 如果seo的内容来自于接口(即动态数据)则不能生效
    * 优点：
        仅需要几个页面做seo
2. 服务器渲染(Nuxt.js)
    项目上线流程
     1. `npm run build`
     2. 将打包完成的文件单独拷贝出来
     3. 将四个文件`nuxt.config/.nuxt/package.json/static`放在服务器上，服务器安装node环境
     4. `npm install`
     5. `npm run start`
     6. `nginx`设置代理

## Webpack性能优化
1. 优化构建速度
    1. 升级新版本
    2. 优化搜索文件
        1. 缩小文件的搜索范围（合理使用resolve功能，resolve.alias/配置loader时，使用exclude,include）
        2. 使用module.noParse告诉webpack不必解析哪些文件
    3. 通过Dllplugin和ReferencePlugin避免重复编译第三方库
    4. 使用HappyPack开启多进程Loader转换
    5. 使用ParalleUgifyPlugin多进程压缩JS文件
2. 优化开发体验
    开启热更替HMR

    > 模块热更新不刷新整个网页只重新编译发生变化的模块，并用新模块替换老模块

3. 优化输出质量——压缩文件体积
    1. 通过DefinePlugin区分环境
    2. 压缩资源
    3. 使用Tree Shaking剔除无用代码
    4. gzip压缩
    5. 第三方库用cdn引入

## Vue2和Vue3的区别
1. 双向绑定的原理发生了变化

    > Object.defineProperty对于数组拦截有问题，且需要深度递归遍历才能对对象完全拦截
    proxy不仅可以对数组拦截，还能对Map,set实现拦截，另外Proxy的拦截是懒处理行为，如果用户没有访问嵌套对象，那么不会实现拦截，这就让初始化的速度和内存占比都改善

2. Vue3支持碎片，即可以在组件中放置多个根节点
3. Vue3采用Composition Api, Vue2使用Option Api
4. 建立数据的方式
5. 生命周期钩子函数
6. 父子传参方式不同
7. Vue3新增了Teleport瞬移组件

## Vue组件扩展
在设计组件时，希望它越小越好，功能越专注越好，但是适用场景较小，此时就需要对它就行扩展，即高阶组件。

    * 常见的组件扩展方式：mixins,slots,extends
        1. mixins比较混乱，有全局有局部的，容易冲突
        2. slots适用于容器型组件
        3. extends用于继承组件的基础上再扩展
    * Vue3的Composition Api

## 首屏优化
1. 使用路由懒加载
2. 非首屏组件使用异步组件
3. 不重要的组件延迟加载
4. 静态资源放在CDN上
5. 减少首屏上JS,CSS等资源文件的大小
6. 做一些loading
7. 图片懒加载

## 父子组件传值
1. props + emit
2. 回调函数
3. 通过`$parent`和`$children`访问组件实例
4. provide + inject
5. $attrs可以传递绑定的属性，$listeners可以传递绑定的方法
6. 通过ref获取组件实例

## Vue错误捕获

1. 使用**errorCaptured**钩子

    > 当组件出错后，错误会一直向上抛，但是如果当前组件errorCaptured中返回false则会阻断传播

2. 全局设置错误处理
    ```javascript
    Vue.config.errorHandler = (err, vm, info) => {}
    ```

## diff算法
1. 只比较同一层级，不跨级比较
2. 标签名不同，直接删除，不继续深度比较
3. 标签名相同，key相同，就认为是相同节点，不继续深度比较
