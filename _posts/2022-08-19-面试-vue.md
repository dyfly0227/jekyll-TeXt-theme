---
title: 面试-vue
excerpt: 无可避免的Vue面试题
tags: ['vue','面试']
---

## 路由参数
* `query`要用`path`引入，参数会显示在`URL`上，获取用`this.$route.query`
* `params`要用`name`引入，获取用`this.$route.params`

## 常用修饰符
- `.stop` 阻止冒泡
- `.prevent` 阻止默认行为
- `.capture` 阻止捕获
- `.once` 只触发一次

## nextTick
原理就是生成一个微任务或者延迟宏任务插入任务队列，保证在同一事件循环后执行
优先级（浏览器支持情况不同）：**Promise > MutationObserver > setImmediate > setTimeout**

## VueX
> 采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生改变

**原理**：通过vue的`mixin`机制，借助vue组件的生命周期钩子`beforeCreate`注入`store`对象。即每个vue组件实例化过程中，会在`beforeCreate`钩子前调用`vuexInit`方法。
**使用方式**：
- `this.$store.state.*` | `mapstate` 获取属性
- `this.$store.getters.*`|`mapGetters` 获取属性getter
- `this.$store.dispath()` | `mapActions` 触发action
- `this.$store.commit()` | `mapMutations` 触发mutation

> action里面是可以执行异步操作的，它返回的是一个Promise，所以可以使用store.dispath().then()

## pinia
1. 支持vue devtool,方便调试
2. 模块化设计
3. 轻巧，只有1kb
4. 支持服务器渲染
5. 支持多个store
6. 完整的ts支持
7. pinia只有state,getters,action(同步异步均可)，且触发action不需要`dispath`,直接使用即可

## Vue Router

**工作流程**：
- url改变：`location.hash` | `history.pushState | history.replaceState`
- 触发监听事件：`onhashchange` | `onpopstate`
- 改变vue-router里面的current变量
- 监视currrent变量
- 获取对应的组件
- render新组件

**hash和history的区别**：
- pushState设置新的url可以使与当前url同源的任意url，hash只修改#后面的部分
- pushState设置的新url可以与当前一模一样，这样也会把记录添加到栈里，而hash设置的新值必须与原来不一样
- history刷新必须后端的配合
- pushState可以额外设置`title`属性

**路由钩子**：
- 【全局守卫】`router.beforeEach(to, from, next) `：可以定义多个
- 【全局守卫】`router.beforeResolve(to,from,next)`： 所有**组件内守卫**和**异步路由组件**被解析之后触发
- 【全局守卫】`router.afterEach(to, from)`：没有next，不会改变导航本身
- 【路由守卫】`beforeEnter(to,from,next)`
- 【组件守卫】`beforeRouteEnter(to,from,next)`: this不可用，在`beforeCreate`之前，不过可以通过`next(vm=>{})`的方式
- 【组件守卫】`beforeRouteUpdate(to,from)`：组件被复用时调用
- 【组件守卫】`beforeRouteLeave(to,from)`：可以访问this

**滚动行为**：
```javascript
const router = createRouter({
	scrollBehavior(to,from,savedPosition) {
		return {top:0}
	}
})
```
**优化策略**：
- 路由懒加载
- 把组件按组分块（注释语法来提供chunk name）

**动态路由**：`router.addRoute|removeRoute`

## patchVnode的规则
1. 新老节点均有`children`子节点，则对子节点执行`diff算法`，调用`updateChildren()`
2. 新节点有子节点，而旧节点没有，则先清空旧节点的内容，然后为其新增子节点
3. 如果新节点没有子节点，而旧节点有，则移除该节点的所有子节点
4. 当新旧节点都没有子节点时，则仅是文本的替换

## Vue Seo
1. 预渲染
    * vue插件：`prerender-spa-plugin`
    * 解决title,描述,关键词插件：`vue-meta-info`
    * 打包结果：会有多个html页面
    * 缺点：
        1. 需要对每个路由进行配置，不适合多个页面seo
        2. 如果seo的内容来自于接口(即动态数据)则不能生效
    * 优点：
        仅需要几个页面做seo
2. 服务器渲染(Nuxt.js)
    项目上线流程
     1. `npm run build`
     2. 将打包完成的文件单独拷贝出来
     3. 将四个文件`nuxt.config/.nuxt/package.json/static`放在服务器上，服务器安装node环境
     4. `npm install`
     5. `npm run start`
     6. `nginx`设置代理

## Webpack性能优化
3. 优化构建速度
    1. 升级新版本
    2. 优化搜索文件
        1. 缩小文件的搜索范围（合理使用resolve功能，resolve.alias/配置loader时，使用exclude,include）
        2. 使用module.noParse告诉webpack不必解析哪些文件。比如jQuery没有采用模块化标准就无需解析
    3. 使用HappyPack开启多进程Loader转换
    4. 使用ParalleUgifyPlugin多进程压缩JS文件
4. 优化开发体验
    1. 开启热更替HMR

    > 模块热更新不刷新整个网页只重新编译发生变化的模块，并用新模块替换老模块

    2. 开启缓存
    3. Devtool

5. 优化输出质量——压缩文件体积
    1. 通过DefinePlugin区分环境
    2. 压缩资源
    3. 使用Tree Shaking剔除无用代码
    4. gzip压缩
    5. 第三方库用cdn引入
    6. 去掉比较大的库的无用代码。需要在网上寻找对应插件，比如lodash

## 前端性能优化
1. 浏览器
    1. 减少HTTP请求。合并css,雪碧图
    2. 使用HTTP2(多路复用，首部压缩，服务器主动推送)
    3. 设置缓存
    4. 静态资源服务器
    5. GZIP
    6. CDN
    7. 字体图标代替图片图标
    10. 使用webp格式图片
    11. 小图片转成base64
2.  代码优化
    1. 慎用全局变量
    2. 减少重绘回流
    3. 节流，防抖
    4. 避免滥用闭包
    5. 文档碎片
    6. 避免table布局
    7. 避免iframe嵌套
    8. web worker开启多线程
    9.  图片懒加载，预加载，响应式加载（根据屏幕大小加载对应图片），调整图片大小（先加载小图，鼠标悬停后加载大图）
    10. 长列表滚动加载
3. 用户体验优化
    1. 白屏动画加载优化
    2. SSR

## Vue2和Vue3的区别
1. 双向绑定的原理发生了变化

    > Object.defineProperty对于数组拦截有问题，且需要深度递归遍历才能对对象完全拦截
    proxy不仅可以对数组拦截，还能对Map,set实现拦截，另外Proxy的拦截是懒处理行为，如果用户没有访问嵌套对象，那么不会实现拦截，这就让初始化的速度和内存占比都改善

2. Vue3支持碎片，即可以在组件中放置多个根节点
3. Vue3采用Composition Api, Vue2使用Option Api
4. 建立数据的方式
5. 生命周期钩子函数
6. 父子传参方式不同
7. Vue3新增了Teleport瞬移组件

## Vue组件扩展
在设计组件时，希望它越小越好，功能越专注越好，但是适用场景较小，此时就需要对它就行扩展，即高阶组件。

    * 常见的组件扩展方式：mixins,slots,extends
        1. mixins比较混乱，有全局有局部的，容易冲突
        2. slots适用于容器型组件
        3. extends用于继承组件的基础上再扩展
    * Vue3的Composition Api

## 首屏优化
1. 使用路由懒加载
2. 非首屏组件使用异步组件
3. 不重要的组件延迟加载
4. 静态资源放在CDN上
5. 减少首屏上JS,CSS等资源文件的大小
6. 做一些loading
7. 图片懒加载

## 父子组件传值
1. props + emit
2. 回调函数
3. 通过`$parent`和`$children`访问组件实例
4. provide + inject
5. $attrs可以传递绑定的属性，$listeners可以传递绑定的方法
6. 通过ref获取组件实例

## Vue错误捕获

1. 使用**errorCaptured**钩子

    > 当组件出错后，错误会一直向上抛，但是如果当前组件errorCaptured中返回false则会阻断传播

2. 全局设置错误处理
    ```javascript
    Vue.config.errorHandler = (err, vm, info) => {}
    ```

## diff算法
1. 只比较同一层级，不跨级比较
2. 标签名不同，直接删除，不继续深度比较
3. 标签名相同，key相同，就认为是相同节点，不继续深度比较




## 双向数据绑定
首先，总共有个4个模块
    1. `Observer`用于数据劫持，核心方法`get()`和`set()`
    2. `Dep`订阅者容器，和兴方法`addSub()`和`notify()`
    3. `Compile`用于解析模板
    4. `Watcher`充当一个桥梁的角色，核心方法`update()`
具体过程如下：
    1. `Observe`劫持`data`,让`data`中的每一个属性都有对应的`get()`和`set()`
    2. `Compile`解析模板，找到对应的属性，然后执行`new Watcher()`将自身以及更新函数传给`Watcher`
    3. 在`Watcher`的构造函数中，先将`Compile`传过来的更新函数赋予`this.callback`，接着将一个全局对象`Dep.temp`指向`this`，然后触发`Observer`的`get()`,紧接着设置`Dep.temp=null`防止多次订阅。
    4. `Observer`的`get()`会判断`Dep.temp`是否存在，存在则调用`Dep`实例对象的`addSub()`将其订阅
    5. 之后一旦数据发生变动触发`Observe`的`set()`方法，`set()`会执行`Dep`实例对象的`notify()`，执行`Watcher`的`update()`方法
    6. 之后执行`patch`方法执行`diff算法`
   

## 组件的渲染和更新
1. dom被解析为render函数
2. 劫持data为getter和setter
3. 模板初次获取数据(touch)，触发getter
4. Watcher收集依赖（每个组件都有一个Watcher）
5. 修改属性，触发setter
6. setter通知Watcher
7. Watcher触发重新渲染
8. 生成新的虚拟dom
9. 然后使用diff算法path(vnode,newVNode)
10. 更新视图

## vue3的优点
1. vue3性能优化
   1. diff算法添加静态标记，发生变化时直接比较标记的
   2. 静态提升：编译过程中发现一些不会变的节点或者属性，就给这些节点打上标记，然后在生成代码字符串的时候，发现这些静态的节点并提升他们，将它们序列化成字符串。比如，之前编译后是`createVNode('span',{class:"foo"})`,现在是`<span class="foo"></span>`
   3. 事件监听缓存。默认情况下`@click`被认为是动态变量，所以每次更新视图的时候都会追踪它的变化，但正常情况下，`@click`一直都是同一个事件，所以不需要去追踪它
   4.  SSR开发时，vue3直接将静态标签转换为文本，这样就不要先转换为vnode再转换为Html
2. 源码体积缩减，移除了一些不常用API（`$children,过滤器，$on.$off`）,且`Tree shaking`更好，因为所有的模块都需要先引用
3. 响应式由`defineProperty`转换为`proxy`，因为它默认深度监听，可以监听到数组，也可以监听到属性删除
4. 更好的支持ts
5. 组合式API

## watchEffect
与`computed`类似，但是不用写`return`,不用指定监听数据源，回调中用到哪个数据，就监听哪个数据，而且它是立即执行的。
它的作用就是来`优雅化watch`，尤其是依赖于多个数据源时

## vue3组件通信方式
1. props+emit
2. expose + ref：expose来指定子组件对外暴露哪些属性，如果不指定expose，那子组件就没有满足封装性
3. $attrs
4. v-model
5. provide/inject(原型链原理)
6. vuex/pinia
7. mitt

## ref和reactive
`ref`的底层还是用`reactive`来实现的，只不过包装了一下，让它支持基本类型

