---
title: '面试-http相关'
excerpt: '状态码，https，三次握手，网络安全等'
tags: '面试'
---

### 状态码
200 成功
301 永久重定向
302 临时重定向
304 资源未修改，重定向已存在的缓冲文件
403 禁止访问
404 Not Found
502 网关或代理错误
503 服务器忙
### GET和POST
因为HTTP是明文协议，所以两种请求方式都有不安全的问题（对于协议中的安全，GET反倒是安全的，因为它不会修改服务器的资源），GET请求也可以有body体，POST请求也可以不要body体。
**区别：** 
		1. GET请求的所有数据都在url中，浏览器对url的长度是有限制的（解析url需要分配内存）
		2. GET请求能被缓存，所以它回退浏览器无害
		3. GET只允许ASCII字符，POST无限制 
		4. GET可以保存书签，可以保存在浏览记录里
### Cookie
```
key=name; expires=Thu, 25 Feb 2016 04:18:00 GMT; domain=ppsc.sankuai.com; path=/; secure; HttpOnly
```
属性包含过期时间、要发送到哪个域名、哪个路径等
如果域名路径正确,且有`secure`标识，浏览器会自动将cookie添加至`request header`的`cookie`字段里面（跨域请求默认不添加）
如果包含`HttpOnly`字段，就无法通过js去修改
**设置cookie**: 
		1. 服务器返回`response header`里面有一个`set-cookie`专门设置，可以存在多个`set-cookie`
		2. 客户端通过JS设置
**修改cookie**： name/path/domain保持一致，重新设置新值即可覆盖
> 如果未显式设置domain，浏览器会自动获取URL的host

### 跨域
浏览器将请求分为**简单请求**和**非简单请求**
只要满足一下两大条件，就需要简单请求
```
请求方式： HEAD/GET/POST
头信息：
	Accept
	Accept-Language
	Content-Language
	Last-Event-ID
	Content-Type: 只限于三个值 application/x-www-form-urlencodeed、multipart/form-data、text/plain
```
因为历史上表单一直可以发出跨域请求，所以为了兼容表单
##### 简单请求
浏览器直接发出请求，但是在头信息之中，增加一个`Origin`字段，如果`Origin`不在服务器的白名单里，就会抛出错误，被`XMLHttpRequest`的`onerror`捕获（错误码有可能是200，所以不能通过状态码判断）
服务器响应中会多出几个头信息字段，都以`Access-Control-`开头
1. **Access-Control-Allow-Origin**： 域名白名单
2. **Access-Control-Allow-Credentials**/krə'denʃl/ ：可选，是否允许发送Cookie
3. **Access-Control-Expose-Headers**：可选，允许前端从响应头里面拿到其他的字段

> 除了服务器设置Allow-Credentials之外，前端还需要将 withCredentials 设置为true，才能实现跨域请求自动携带cookie，而且因为携带cookie的前提是domain和path一致，所以Allow-Origin不能是*

##### 非简单请求
非简单请求会在正式通信之前，增加一次预检请求（OPTIONS）。先询问服务器当前域名是否在白名单，可以使用哪些头信息字段，只有得到肯定答复，才会发出真正的请求。
预检请求多两个字段
1. **Access-Control-Request-Method**:  请求方法
2. **Access-Control-Request-Headers**： 指定额外发送的头信息字段

预检响应比简单请求多两个字段
1. **Access-Control-Allow-Methods**: 允许的跨域请求方法
2. **Access-Control-Max-Age**： 本次预检的有效期，如果在有效期内，无需另发

### HTTPS
HTTPS就是多一个SSL/TLS安全协议，在TCP三次握手后，还需要进行SSL/TLS握手，才可以进入报文传输。HTTP端口80，HTTPS端口号443。
![运行过程：客户端向服务器申请公钥 >>  客户端生成“对话密钥”并用申请的公钥加密发送给服务器 >> 服务器用私钥解密获得“对话密钥”](https://img-blog.csdnimg.cn/0bff06279fc24b4b84963d969b1c3ca1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAdG8gYmUgZmFu,size_20,color_FFFFFF,t_70,g_se,x_16)
### 缓存
##### 请求资源的优先级
1. Service Worker ：浏览器缓存（Application->Cache Storage），基于web worker，需要网站注册。拦截所有的请求，如果没有缓存，则使用`fetch()`方法继续获取资源（所有资源显示`from ServiceWorker`）
2. Memory Cache：短期存储，几乎所有的请求资源都能进入memory cache，TAB关闭后删除或者为了腾位置提前删除。如果不想进入该缓存，需要使用`no-store`
3. Disk Cache: 持久缓存，根据HTTP头信息中的各类字段判断哪些资源需要缓存。每个浏览器都有各自的算法去清除。
4. 网络请求
##### 强缓存
根据HTTP头信息中的`Cache-control`和`Expires`来缓存
**Expires**: HTTP1.0的字段
```
Expires: Thu, 10 Nov 2017 08:45:11 GMT
```
> 写法复杂，而且是绝对时间

**Cache-control**：HTTP1.1的字段，优先级高于Expires
```
Cache-control: max-age=2592000
			 : must-revalidate: 如果超过max-age的时间，浏览器必须向服务器发送请求，验证资源是否还有效
			 : no-cache
			 : no-store
```
##### 协商缓存
如果客户端发现缓存的资源已过期，就会去询问服务器，服务器就会判断是否真的过期了，如果没过期就返回304，否则返回资源。
资源的响应头信息中包含两个字段：
**etag**: 文件的唯一hash
**last-modified**：上次修改时间
再次请求资源的请求头信息中会携带上面两个属性
**if-none-matched**:  对应etag
**if-modified-since**:  对应last-modified

因为会存在【某些服务器的更新时间不准确】、【文件在秒以下的时间频繁修改】、【文件周期性更改，但是内容未改变】，所以HTTP1.1增加了`Etag`用于优化，它直接与资源进行比对，更加准确。
##### 设置缓存
 - 后端服务器设置
 - nginx配置
##### 浏览器行为
 - 打开网页，查找`disk cache`
 - 普通刷新：先`memory cache`,然后`disk cache`
 - 强制刷新：浏览器不使用缓存

### 头信息字段
请求头
```
Accept
Accept-Encoding
Accept-language
Connection: keep-alive
Content-Length
Content-Type
Host
Oirgin
Referer: 从哪来的，用于跟踪
User-Agent
```
响应头
```
Access-Control-*
Content-Length
Content-Type
Date
Set-Cookie
```
### HTTP各版本
##### 0.9
- 只支持Get请求
- 没有请求头
- 只能传输文本
- 服务器响应后立即关闭TCP连接
##### 1.0
- 新增POST、DELETE、PUT、HEADER
- 增添请求头和响应头
- 扩充了传输内容格式

特性：
**无状态**：服务器不跟踪记录请求过的状态（可以借助cookie/session）
**无连接**： 每次请求都需要建立TCP连接
##### 1.1
- 默认保持长连接（keep-alive）
- 管道化：基于长连接，管道化可以不等第一个请求响应继续发送后面的请求，但是响应顺序还是按照请求顺序返回，也会堵塞
- 缓存处理（cache-control）
- 断点传输：将资源分割分别上传/下载

##### 2.0
- 多路复用，同域名下所有通信都在单个连接上完成
- 二进制分帧，将资源分的更小
- 服务器主动推送
- 报头压缩

### 网络安全
##### 跨站请求伪造（CSRF）
```
登录淘宝
登录信息存入cookie
未关闭淘宝的情况下，访问钓鱼网站
钓鱼网站获取淘宝的cookie，并发送请求给淘宝服务器
```
防范：
- 验证`Referer`字段
- 请求头/体携带token
- 修改数据使用POST请求

##### 跨站脚本攻击（XSS）
```
攻击者在目标网站植入恶意脚本，比如在输入框中输入JS代码，页面渲染时执行恶意脚本会导致用户敏感信息泄露，或修改WEB页面等
```
防范：
- 输入内容过滤和转译
- 重要内容加密传输
- Cookie设置`HTTP Only`属性

### 三次握手四次挥手

![在这里插入图片描述](/assets/images/182e0b541a6345cfb31245d469677c86.png)

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭，所以即使没有最后一个包，也需要先回复断开连接的请求，然后再发送关闭请求


三次握手之所以是三次是保证client和server均让对方知道自己的接收和发送能力没问题而保证的最小次数。

第一次client => server 只能server判断出client具备发送能力
第二次 server => client client就可以判断出server具备发送和接受能力。此时client还需让server知道自己接收能力没问题于是就有了第三次
第三次 client => server 双方均保证了自己的接收和发送能力没有问题

其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的ACK都会对这个seq进行加一来进行确认。

> 在短时间间隔内的HTTP请求是不需要再次建立握手的，约定需要客户端和服务端双方的确定