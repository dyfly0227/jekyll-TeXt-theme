---
title: Git操作
excerpt: Git操作指令合集
tags: git
---
## git的4个区
1. 工作区——本地目录
    `git diff`可以查看修改但未缓存的文件内容差异
2. 暂存区——git add 之后的存放区
    `git diff --cached`可以查看已缓存但未提交的文件内容差异
3. 本地仓库——git commit 之后的存放区
    `git diff 本地分支 远程分支` 可以查看已提交本地但未推送到远程的文件内容差异
4. 远程仓库

## 回退
查看日志
```bash
git log 
git reflog # 可以查看所有记录，包括已经被删除的commit记录
```
回退类型区分
```bash
git reset --hard # 进行commit之前的回退
git reset --hard origin/master # 进行commit之后Push之前的回退
git push -f # 如果已经push上去了，则先回退，然后强制推送覆盖远程
```
回退命令区分
```bash
git reset --hard head # 回退到当前版本
git reset --hard HEAD^ # 回退到上个版本
git reset --hard HEAD~3 # 回退到往上3个版本
git reset --hard 版本号 # 回退到制定版本
git reset --soft head # 回退到当前版本，且修改的内容保存
```
放弃某个文件的修改
```bash
git checkout -- filename
```

## SSH key
查看ssh是否已经存在
```bash
# window
查看目录C:/用户/用户名/.ssh文件夹下是否有 id_rsa.pub 文件
# mac
cd ~/.ssh
ls
```
如果不存在，则生成
```bash
ssh-keygen -t rsa -C "emailaddress"
# 然后一路回车
```
复制ssh key
```bash
# window下直接打开id_rsa.pub文件复制内容
# mac
cd ~./ssh
cat id_rsa.pub
```
删除
```bash
# window 直接.ssh文件夹
# mac 
cd ~ 
rm -rf .ssh
```
## 用户名和邮箱
```bash
git config --list
git config user.name 'xxxx'
git conifg user.email 'xxxxx@xx.com'
```
## 关联远程仓库
```bash
git remote add origin 远程仓库地址
git remote rm origin # 取消关联
```
## 管理分支
```bash
git branch # 查看本地分支
git branch -r # 查看远程分支
git bracn -a # 查看本地和远程的所有分支，以及映射关系
git checkout 分支名 # 切换分支
git checkout -b 分支名 # 创建分支
git checkout -b 分支名 origin/远程分支名 # 从远程分支创建一个新分支，并予以映射
git branch -m 旧名 新名 # 重命名分支
git branch -D 分支名 # 删除分支
git push --delete origin 远程分支名 # 删除远程分支
```

## 修改commit信息或更改change-id
```bash
git commit --amend
```
> 如果git项目需要审核入库，每个提交都会有一个change-id，一旦本地仓库冲突后，解决冲突后仍无法push，原因就是change-id未更新，此时需要重新commit一下，让hook重新生成新的change-id

## 撤销某一个提交
> 提交了4个记录，但是第二个记录有问题，需要撤回

```bash
git revert -n 第二个记录的版本号
git commit -m 'revert second record'
git push
```
也可以用`git rebase -i`将某个commit drop掉

## 解决冲突
提前避免冲突
```bash
git stash # 将本地修改储藏起来
git pull # 拉取最新代码
git stash pop # 将本地修改还原回来并删除(刚存储的所以在最后一个)
# git stash其他命令
git stash save 名称 # 起个名字好辨识
git stash list 
git stash apply stash@{index} # 取出指定的记录
git stash drop stash@{index} # 删除指定的记录
```
commit之后发生了冲突，而且解决冲突有点混乱
```bash
git log # 复制获取当前commit的版本号
git checkout -b 新分支名 origin/dev # 创建新分支
git pull # 拉取最新代码
git cherry-pick 复制的版本号
# 解决冲突
git add .
git cherry-pick --continue
git commit -m 'commit message'
git push 
# 之后删除当前分支，然后回到原来分支回退到之前版本，然后更新
```

## 合并多个commit
```bash
git rebase -i [start][end] # end可以省略，表示从起始到最后一个
```

## 合并分支
```bash
[c1] -- [c4] -- c[5]  # master分支 
    \                  
     \  [c2] -- c[3] # feature分支
```
在`C1`节点创建新分支`feature`开发新功能，总共提交了两次`c2,c3`,`master`分支开发原来功能也提交了两次`c4,c5`,此时新功能开发完了需要合并回来。
```bash
# 方式1
git checkout master
git merge feature
```
过程如下：
    1. 找到`feature`和`master`的共同祖先节点`c1`
    2. 把`feature`分支的最后一次提交`c3`和`master`分支上最后一次提交`c5`合并，此时若有冲突，则解决冲突，然后生成一个新的commit节点`c6`
    3. 根据两个分支上的commit时间的先后顺序，依次放到`master`分支上，使用`git log`可以看到时间顺序
最终合并结果：
```bash
[c1] -- [c2] -- [c4] -- c[5] -- c[3] -- c[6] # 时间顺序2>4>5>3
```
优点： 
    * 保证了每个commit都按照顺序排列
缺点：
    * 分支图凌乱，而且多了一个没有意义的c6节点
```bash
# 方式2
git checkout feature # 切换到feature分支
git rebase master # 变基
```
过程如下:
     1. 找到当前`master`分支最新的节点`c5`,将`feature`分支的基点变为`c5`节点。即`feature`当前所有的提交都是基于`c1`节点的，用了`rebase`之后，就将`c5`替换了`c1`。

最终合并结果：
```bash
[c1] -- [c4] -- [c5] -- c[2] -- c[3]  # c5变成了基点，所以当前feature领先master两个节点。
```
优点： 
    * 提交记录就是一条线，比较优雅
缺点：
    * commit时间线错乱