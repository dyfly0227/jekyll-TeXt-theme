---
title: 'set和map'
excerpt: '关于set,map,weekset,weekmap不得不说的故事'
tags: 'js'
---

### set
**Set 本身是一种构造函数，用来生成 Set 数据结构**
```javascript
new Set([iterable]) // 参数必须时可迭代的，比如数组
```
![](/assets/images/20210615164355155.png)
`Set`是一种**集合**，形式是[value, value]，即**key跟value是一致的**

所以可以用`new Set()`来去重，因为不可能存在相同的`key`
```javascript
// 去重数组的重复对象
let arr = [1, 2, 3, 2, '5', 5]
[... new Set(arr)]	//  [1, 2, 3, "5", 5]
```
> Set内部判断两个值是否相等的算法类似于`===`，所以5跟'5'是不同的值


实例属性：
* size: 元素数量
操作方法：
* add(value): 相当于push
* delete(value)
* has(value)
* clear()

遍历方法：
* keys(): 返回包含所有key的迭代器
* values(): 返回包含所有value的迭代器
    > 因为`Set`集合的`key`跟`value`一样，所以`keys()`和`values()`返回的值一致
* entries(): 返回包含所有元素的键值对迭代器
* forEach

### Map
**Map 本身也是一种构造函数，用来生成 Map 数据结构**，它的参数是**具有Iterator接口、且每个元素都是一个双元素的数组**

> map是用来弥补对象的key只能是字符串的缺陷

```javascript
new Map([['foo',1],['bar',2]])
```
`Map`是一种**字典**，形式是[key, value]
![](/assets/images/20210615164410208.png)

实例属性：
* size: 元素数量
操作方法：
* set(key,value)
* get(key)
* delete(value)
* has(value)
* clear()

遍历方法：
* keys(): 返回包含所有key的迭代器
* values(): 返回包含所有value的迭代器
* entries(): 返回包含所有元素的键值对迭代器
* forEach

### WeakSet 和 WeakMap
弱引用，为了垃圾回收机制而生,见[浏览器垃圾回收机制](https://blog.csdn.net/yingmd2020/article/details/117928175)最后一段；
因为它俩为垃圾回收机制而生，所以必须保证一点，那就是**值必须放在堆里面**,基于上面`set集合`和`map字典`的属性，**`WeakMap`的`key`必须是个引用对象，`WeakSet`的元素也必须是个引用对象**

```javascript
let s = new WeakSet()
s.add([1,2]) // 数组
s.add({a:1}) // 对象
s.add(function(){}) // 函数
s.add(document.querySelector('#test')) // DOM节点
```
WeakMap
```javascript
let m = new WeakMap()
const o1 = {},
      o2 = function() {}
m.set(o1, 37)
m.set(o2, 'Hello world')
m.get(o1) // 37
m.get(o2) // Hello world
```
这个看起来很奇怪，`key`必须是个引用对象，所以必须单独声明`o1,o2`，这样跟直接声明`let m = 'Hello World'`有什么区别
答案： **WeakMap是个弱引用，它的值在堆里面，如果它不使用就会被垃圾回收机制自动回收了，这样`key`也无效了，自然也会被回收**

> WeakSet 和 WeakMap 不能遍历