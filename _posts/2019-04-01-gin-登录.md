---
title: 'gin 登录'
excerpt: '登录验证及token的生成'
tags: 'go'
---

### 思路
常规思路：用户登录 -> 服务器生成session -> 返回sessionId给客户端 -> 客户端将sessionId存入cookie并每次请求携带 -> 服务器根据请求携带信息判断身份信息
进化思路：也懒得用JWT，就把用户信息存入redis中，把Key返回给客户端存入cookie
### 实现
```go
// Controller/user.go
func (t *UserController) Login(c *gin.Context) {
	data, err := ioutil.ReadAll(c.Request.Body)
	CheckError(err)
	var msg struct {
		UserName string
		Password string
	}
	json.Unmarshal(data, &msg)
	res, _ := Service.UserServer.UserList(fmt.Sprintf("username = '%s'", msg.UserName), 1, 1)
	if len(res) > 0 && res[0].Password == msg.Password {
		// 生成随机字符串
		str := RandStr(32)
		result, _ := json.Marshal(res[0])
		// 将用户信息存入redis中，设置过期时间为10分钟
		Redis.SetRedis(str, string(result), 60*10)
		ResponseSuccessMap(c, map[string]interface{}{
			"token":    str,
			"userinfo": res[0],
		})
	} else {
		ResponseError(c, "error5")
	}
}
```
### 判断用户信息
配合路由拦截使用
```go
func GetCurUserinfo(c *gin.Context) (Model.Account, error) {
	header := c.Request.Header
	var user Model.Account
	// 前端将key存放在"X-Access-Token"中
	if _, ok := header["X-Access-Token"]; ok {
		userinfo := Redis.GetRedis(header["X-Access-Token"][0])
		if userinfo == "" {
			return user, errors.New("")
		} else {
			json.Unmarshal([]byte(userinfo), &user)
			Redis.ExpireRedis(header["X-Access-Token"][0], 60*10) // 每次触发查询则重置过期时间
		}
		return user, nil
	}
	return user, errors.New("fail")
}
```
### 生成随机key
同时用于id的生成
```go
// RandStr 生成随机字符串
func RandStr(length int) string {
	str := "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
	bytes := []byte(str)
	result := []byte{}
	rand.Seed(time.Now().UnixNano() + int64(rand.Intn(100)))
	for i := 0; i < length; i++ {
		result = append(result, bytes[rand.Intn(len(bytes))])
	}
	return string(result)
}
```