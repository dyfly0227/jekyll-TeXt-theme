---
title: 'ts基础知识'
excerpt: '接口，泛型，type等'
tags: ['面试','ts']
---

## interface任意属性
```ts
interface Person {
  readonly id: string // 只读
  name: string
  sex?: string // 可选属性
  [propName:string]: string // 定义任意属性，key为string,value为string
  age: number // 此处会报错，因为定义了任意属性value为string，age也属于其中
}
```

> 也可以用Record<string,string>, 或者Record<number, Person>

## interface定义函数
```ts
interface Fuc {
  // (参数:类型, ...) : 返回类型
  (a:string, b:string) : boolean
}
```
## 函数剩余参数
```ts
function fn(x:string,y:string,...args:string[]) {
  // 该方法可以接收至少两个，最多不限的参数
}
```
## 函数重载
```ts
function add (a:number, b:number):number {}
function add (a:string, b:string):string {}
```
## 类型断言
```ts
function getLength(x:string|number):number {
  return x.length;
}
getLength(2); // 报错，number没有length属性
// 解决方法
(x as string).length // 断言方式1s
(<string>x).length // 断言方式2
```
## type和interface的异同
1. interface只能表示对象类型，type还可以定义基本类型和对象类型
2. type可以联合类型，比如`type a = number|string`
3. type和interface都可以继承，interface用extends，type用&，而且可以相互继承
4. interface声明多个同名会合并，type声明多个同名会报错，所以interface可以实现拓展第三方库的interface

## 元组
数组所有元素是同一类型，元组就是可以包含不同类型的数组
```ts
let Tarr = [string, number] = ['123',123]
```
## 枚举
枚举就是给一组数据赋予名称
```ts
enum NumberType {
  one = 1, // 手动赋值为1，如果没有赋值，默认为0
  two, // 根据前面的值依次递增，
  three = 11,
  four // 值为12
}
```
应用场景
```ts
enum Color {
  red,
  blue,
  yellow
}
const c:Color = Color[1] // blue
```
## 类
### 类的继承
```ts
class Animal {
  name: string
  age: number
  constructor(name:string, age:number) {
    this.name = name;
    this.age = age;
  }
  sayHi(str: string) {
    console.log('Hi' + str)
  }
}
class Dog extends Animal {
  category: string
  constructor(name:string, age:number, category: string) {
    // 调用父类的构造函数
    super(name,age);
    this.category = category;
  }
  // 重写父类方法
  sayHi(str: string) {
    console.lot('Hello' + str)
    // 调用父类的sayHi方法
    super.sayHi('nike')
  }
}
```
### 类的存取器
```ts
class Person {
  firstName: string
  secondName: string
  constructor(firstName:string, secondName:string) {
    this.firstName = firstName;
    this.secondName = secondName;
  }
  get fullName() {
    return this.firstName + this.secondName
  }
  set fullName(value: string) {
    const names = value.split('-')
    this.firstName = names[0];
    this.secondName = names[1];
  }
}
const p = new Person('zhang','dada')
console.log(p.fullName)
p.fullName = 'song-lala'
console.log(p.fullName)
```
### 类的静态成员
```ts
class Person {
  static ss = 'world'
  static walk() {
    console.log(this.ss)
  }
  sayHi() {
    console.log(this.ss) // 报错，非静态方法不能使用静态属性
  }
}
const p = new Person()
console.log(p.name) // 报错
p.walk() // 报错
console.log(Person.ss) // world
Person.walk() // world
```
静态成员仅属于当前类，不能被继承，而且静态属性只能在静态方法里面使用
### public,private,protected
```ts
class Animal {
  public a:string
  private b:string
  protected c:string
  constructor(a:string,b:string,c:string) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
}
class Dog extends Animal {
  constructor(a:string,b:string,c:string) {
    super(a,b,c)
  }
  sayHi() {
    console.log(this.a) // 11 
    console.log(this.b) // 报错，private是私有属性不能继承
    console.log(this.c) // 33
  }
}
const d = new Animal('11','22','33')
console.log(d.a) // 11 
console.log(d.b) // 报错，私有属性只能在类内部使用，实例对象也不能访问
console.log(d.c) // 报错，保护属性只能在子类内部使用，实例对象也不能访问
```

### 构造函数参数属性
```ts
class Person {
  constructor(readonly age:number) {
    // 这个操作默认会执行 this.age = age，且age只能读取不能修改
    // 同理public,private,protected也能这样用
  }
}
```
### 抽象类
```ts
// 抽象类，就是为子类服务，只能被继承，不能被实例化，类似与interface是个约束
// 抽象类里面的属性和方法，子类必须全部实现，否则会报错，抽象属性和方法不能被继承
abstract class Car {
    abstract name:string
    abstract run():void  // 抽象方法没有具体实现
}
class Baoma extends Car {
    name:string
    constructor(name:string) {
        super()
        this.name = name
    }
    run() {
      
    }
} 
```
### 类实现接口
```ts
interface ISing {
    sing():void
}
interface IDance {
    dance():void
}
// 类实现接口用implements关键字，多个接口用逗号隔开，继承后就必须实现接口的属性和方法，有点类似抽象类
class Person implements ISing,IDance {
    sing() {
        console.log('i am sing')
    }
    dance() {
        console.log('i am dance')
    }
}
```
## 泛型
不预先指定类型，而在使用的时候再指定一个类型
```ts
// T表示输入任意类型
function getArr<T>(value:T, num: number):T[] {
    const arr:T[] = []
    for(let i=0; i< num;i++) {
        arr.push(value)
    }
    return arr
}
getArr<string>('123',3)
getArr(2,3) // 不指定<number>也行，它会自己类型判断
```
多个泛型参数
```ts
// 反转元组
function reverse<T,U>(value:[T,U]):[U,T] {
    return [value[1],value[0]]
}
reverse(['123',456])
```
### 泛型约束
```ts
interface ILength {
    length: number
}
// 约束这个泛型必须有length属性
function getLength<T extends ILength>(val:T):number {
    return val.length;
}
```
### 泛型接口
```ts
interface IPerson<T> {
  name: T
}
const p:IPerson<number> = {
  name: 123
}
```
### 泛型类
```ts
class Person<T> {
    age: T
    constructor(age: T) {
        this.age = age
    }
}
const p = new Person<number>(22)
```