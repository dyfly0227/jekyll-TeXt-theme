---
title: 'electron多窗口'
excerpt: 'electron多窗口的创建与注销，以及窗口之间的通信'
tags: 'electron'
---

## 管理窗口

声明一个全局对象`global`，有两个属性`mainWin-主窗口`，`childWins-子窗口（多个）`
> `ts`中不声明编辑器会一直报错，虽然不声明也能用。
```ts
// global.d.ts
import { BrowserWindow } from 'electron'
declare global {
  namespace NodeJS {
    interface Global {
      mainWin: BrowserWindow
      childWins: Map<string, BrowserWindow>
    }
  }
}
```
封装一个方法专门用来操作窗口
```ts
import { BrowserWindow } from 'electron'
import path from 'path'
// 初始化 指定主窗口，创建子窗口容器
export const initMain = (win: BrowserWindow) => {
  global.mainWin = win
  global.childWins = new Map<string, BrowserWindow>()
}
// 关闭所有子窗口
export const closeAllWin = () => {
  global.childWins.forEach((item) => item.close())
  global.childWins.clear()
}
// 关闭指定子窗口
export const closeWin = (key: string) => {
  const win = global.childWins.get(key)
  if (win) {
    win.close()
  }
}
// 创建一个子窗口，params.name为主标识
export const openNewWindow = (params) => {
  const win = global.childWins.get(params.name)
  if (win) {
    win.focus()
  } else {
    const winURL =
      process.env.NODE_ENV === 'development'
        ? `http://localhost:8080`
        : `file://${__dirname}/index.html`
    const newWin = new BrowserWindow({
      width: 900,
      height: 620,
      minWidth: 900,
      minHeight: 620,
      autoHideMenuBar: true,
      webPreferences: {
        nodeIntegration: true,
        contextIsolation: !process.env.ELECTRON_NODE_INTEGRATION
      }
    })
    global.childWins.set(params.name, newWin)
    newWin.loadURL(winURL + `#${params.path}`)
    newWin.on('close', () => {
      global.childWins.delete(params.name)
    })
  }
}
```
## 窗口通信
```ts
// 客户端发送创建窗口的指令
export const openAddProjectWindow = (
  params: Pick<RequestParams, 'name' | 'path'>
) => {
  ipcRenderer.send('new-window', params)
  // 接收主线程的通信： 新建项目完成后，关闭子窗口
  ipcRenderer.on('add-project-back', (event, res: Record<string, any>) => {
    store.commit('SET_PROJECT_ID', res.id)
    closeWindow({
      name: 'addProject',
      path: '/loading'
    })
  })
}
```
```ts
// node端主窗口接收创建窗口指令
ipcMain.on('new-window', (event, params) => {
  openNewWindow(params)
})
```
此时子窗口的任务完成了，需要关闭子窗口
```ts
// 子窗口客户端发送完成指令
ipcRenderer.invoke('add-project', (event, params) => {
})
```
```ts
// node端子窗口接受指令，然后调用主窗口的方法发送`add-project-back`
ipcMain.handle('add-project', (event, params) => {
  addProject(params).then(() => {
    global.mainWin.webContents.send('add-project-back', params)
  })
})
```

> 客户端用send发送,node端用on接收，可直接通过event.returnValue = ''返回结果

> 客户端用invoke发送，node端用handle接收，返回的是一个proise对象