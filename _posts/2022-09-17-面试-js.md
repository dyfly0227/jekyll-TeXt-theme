---
title: '面试-js相关'
excerpt: '闭包，原型，event loop，promise'
tags: '面试'
---

### event.currentTarget
指显式附加事件处理程序的元素

### 闭包
函数A返回了函数B，函数B执行的时候访问了A中变量，那么闭包就产生了。【闭包就是函数A】
**特点**：当函数执行完后，该函数的执行上下文就会失去引用，占用的内存就会被垃圾回收机制释放，但是闭包的存在，会阻止这一过程
**应用场景**：
- getter/setter： 函数返回getter和setter(相当于命名空间)
- 柯里化
- 防抖节流

> 更新理解：闭包就是实现了一个没有污染的全局变量。

### 变量提升函数提升
- 变量提升提升的事变量的声明，变量的声明会提高至顶端，赋值仍在原来位置
- 函数提升会将整体剪贴至顶端
- 变量提升优先级大于函数提升
- class声明会提升，但是不会初始化赋值。类似于let、const

### 原型
为了实现继承，所以有了原型链这个东西
![在这里插入图片描述](/assets/images/7f2cc6975bee41079e92e6e21e703167.png)
继承方法：
1. 构造函数继承 `Father.call(this,'nike')`
	缺点： 【不能继承超类原型上的属性和方法】，【call有多个父类实例的副本，消耗性能】
2. 原型链继承
	缺点： 【不能向父类传递参数】，【引用类型的值会被多个实例共享】，【不能继承多个超类】
3. 组合模式（构造函数+原型链）
	缺点：【需要调用2次超类型构造函数】
4. 寄生组合式
	```javascript
	function inherit(Sub,Sup) {
		var p = Object.create(Sup.prototype);
		p.constructor = Sub;
		Sub.prototype = p;
	}
	```

### 暂时性死区
`let/const`是不会变量提升的，`let/const`会将当前区块形成封闭的作用域，在这个作用域下，从进入到变量声明之间的一段时间，就称之为【暂时性死区】,在暂时性死区，变量都是不可用的
```javascript
typeof a // ReferenceError: a is not defined
let a
```

### let、const、var
var的话会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针

let的话，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错

const的话，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性
### this指向
- 单独使用，指向全局对象window,严格模式下，指向`undefined`
- 函数内部，只要函数执行的时候才能确定
- 方法中，指向调用方法的对象
### 数组的深拷贝
- JSON.stringify 和 JSON.parse
- slice(0)
- concat
- map
- 解构赋值
### 数据去重
1. set：`[...new Set(arr)]`
2. filter
	```javascript
	arr.filter((item,index,array)=>{
		return array.indexIf(item) === index;
	})
	```
	缺点：会过滤`NAN`,`Array.indexOf(NAN) === -1`
3. reduce
	```javascript
	arr.reduce((pre,cur)=>pre.includes(cur)?pre:[...pre,cur],[])
	```
### 箭头函数
- 没有this，只能从上一层作用域继承
- 继承的this指向永远不变
- 不能作为构造函数
- 没有arguments
- 没有prototype
- 不能做Generator函数，不能使用yeild



### Promise
**Promise A+ 规范**：
- 三种状态，且状态改变不可逆，`pending->fullfilled`或`pending->rejected`
- 一个`promise`必须有一个`then`方法
- `then`必须返回一个`promise`

**手写`Promise.all`**
```javascript
function PromiseAll(promiseArray) {
	return new Promise((resolve,reject) => {
		const res = new Array(promiseArray.length);
		let counter = 0;
		promiseArray.foreach((item,index)=>{
			item.then(value => {
				counter ++;
				res[index] = value;
				if(counter === promiseArray.length) {
					resolve(res)
				}
			}).catch(e=>reject(e))
		})
	})
}
```
**手写`Promise.race`**
```js
Promise._race = promises => new Promise((resolve, reject) => {
	promises.forEach(promise => {
		promise.then(resolve, reject)
	})
})
```

### 任务队列和事件循环
**宏任务**：
- script
- setTimeout
- setInterval
- setImmediate(非标准，不建议使用)
- I/O
- UI render

**微任务**：
- Promise.then/catch/finally
- MutationObserver（监视对DOM树所做的更改）


> await 返回的是一个promise，所以await下面的内容相当于在`Promise.then`里面

> 先执行宏任务，再执行微任务

**执行机制**：
1. 同步任务在主线程顺序执行，异步任务会进入另外一个任务队列，不会阻塞主线程
2. 主线程空了后，去异步队列，将异步任务加入主线程执行
3. 定时器也是一种异步任务，浏览器有一个独立的定时器模块，当定时器到了可执行状态，就会被加入主线程

### requestAnimationFrame
执行时间与屏幕刷新率保持一致，它是**由系统来决定回调函数的执行时机**
- 页面隐藏或最小化的时候，刷新任务会停止，CPU节能
- 函数节流：刷新间隔内函数只执行一次
### Web Worker
JS采用的事单线程模型。Web Worker就是为JS创造多线程环境
- worker线程的脚本必须与主线程同源
- worker线程无法读取主线程网页的DOM对象。无法使用`document`、`window`对象。但是有`navigator`和`location`对象
- 与主线程不能直接通信，必须通过消息完成
- 不能使用`alert()`，但是可以使用`XMLHttpRequest`发出AJAX请求
- 不能读取本地文件

**基本用法**：
```js
// 新建worker线程
var worker = new Worker("work.js")
// 向worker线程推送消息
worker.postMessage("Hello world")
// 接收来自worker线程的消息
workder.onmessage = function(event) {
	console.log(event.data)
}
// 监听worker发生错误
worker.oneeror(function(event))
// 关闭线程
worker.terminate();
```
```javascript
// work.js
this.addEventListener("message",function(e) {
	// 接收并发送
	this.postMessage("收到消息" + e.data)
	this.close(); // 内部关闭自身
})
```
**应用场景**：轮询

### 设计模式
1. 工厂模式，比如`new Person()`
	
2. 单例模式，比如【动态弹窗的创建】
	**优点**：减少全局变量
3. 代理模式，比如`Proxy()`,或者HTML元素事件代理`ul.addEventListener("click",()=>{})`
4. 观察者模式，比如 vue的响应式，DOM事件`document.body.addEventListener("click",()=>{})`click触发多个响应
	**缺点**：对象与对象之间联系弱化，程序难以理解和追踪
5. 策略模式，如表单的验证，


### new 过程
- 创建一个空对象，并将空对象的`__proto__`指向构造函数原型对象
- 使用`apply`将属性和方法添加到空对象的`this`上
- 如果构造函数返回一个`Object`，则返回这个`Object`，否则返回这个空对象

```js
function _new(fn,...arg) {
	let obj = Object.create(fn.prototype);
	const result = fn.apply(obj,...arg);
	return Object.prototype.tostring.call(result) === "[object Object]" ? result : obj;
}
```

### 深度遍历（DFS）和广度遍历（BFS）
```js
// DFS
function deepFirstSearch(node,nodeList) {
	if(node) {
		nodeList.push(node);
		let children = node.children;
		for(let i=0;i<children.length;i++) {
			deepFirstSearch(children[i],nodeList)
		}
	}
	return nodeList;
}
```
```js
// BFS
function breadthFirstSearch(node) {
	let nodes = [];
	if(node != null) {
		let queue = [];
		queue.unshift(node);
		while(queue.length > 0) {
			let item = queue.shift();
			nodes.push(item);
			let children = item.children;
			for(let i = 0;i < children.length; i++) {
				queue.push(children[i]); // 先进先出
			}
		}
	}
	return nodes;
}
```

### 避免重绘重排
- 避免`table`布局（反复计算，通常需要三倍时间渲染）
- `visible`代替`display`，`transform`代替`top`
- 避免多层内嵌样式`div > span > a`
- 将动画效果应用在`absolute`和`fixed`元素上
- 避免CSS表达式
- 避免频繁操作样式
- 避免频繁操作DOM

### 隐式转换
```js
// 如何成功输出1
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	console.log(1);
}
```
```js
var a = {
	i: 1,
	toString(){
		return this.i ++;
	}
}
```
### 类数组

```js
var obj = {
    '2': 3,
    '3': 4,
    'length': 2,
    'splice': Array.prototype.splice,
    'push': Array.prototype.push
}
obj.push(1) // length变成3，当前索引为2
obj.push(2) // length变成4，当前索引为4
console.log(obj) // [空 ×2, 1, 2, splice: ƒ, push: ƒ]
```
当一个对象有`splice`属性和`length`属性时，它就是一个类数组，类数组不能使用数组的方法。
且`splice`必须是个函数，否则只会改变`length`
```js
var obj = {
    '2': 3,
    '3': 4,
    'length': 2,
    'splice': "2",
    'push': Array.prototype.push
}
obj.push(1)
obj.push(2)
console.log(obj) // {2: 1, 3: 2, length: 4, splice: '2', push: ƒ}
```
`push`和`call/apply`一起使用的时候，可应用在类数组，`push`方法通过改变`length`决定从哪里插入给定的值

### 设计 LazyMan 类
```js
LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');
// Hi I am Tony
// 等待了5秒...
// I am eating lunch
// I am eating dinner
// 等待了10秒...
// I am eating junk food
```
设计思路：
```js
class LazyManClass {
    constructor(name) {
        this.taskList = [];
        this.name = name;
        console.log(`Hi I am ${this.name}`);
        setTimeout(() => {
            this.next();
        }, 0);
    }
    eat (name) {
        var that = this;
        var fn = (function (n) {
            return function () {
                console.log(`I am eating ${n}`)
                that.next();
            }
        })(name);
        this.taskList.push(fn);
        return this;
    }
    sleepFirst (time) {
        var that = this;
        var fn = (function (t) {
            return function () {
                setTimeout(() => {
                    console.log(`等待了${t}秒...`)
                    that.next();
                }, t * 1000);  
            }
        })(time);
        this.taskList.unshift(fn);
        return this;
    }
    sleep (time) {
        var that = this
        var fn = (function (t) {
            return function () {
                setTimeout(() => {
                    console.log(`等待了${t}秒...`)
                    that.next();
                }, t * 1000); 
            }
        })(time);
        this.taskList.push(fn);
        return this;
    }
    next () {
        var fn = this.taskList.shift();
        fn && fn();
    }
}
function LazyMan(name) {
    return new LazyManClass(name);
}
```

### a.b.c.d 和 a['b']['c']['d']，哪个性能更高？
`a.b`性能更好，因为`[]`还得考虑变量

### input监听中文输入
- `compositionstart`切换为中文输入法，准备输入的时候触发
- `compositionupdate`每打一个拼音字母触发
- `compositionend`输入好的中文填入input触发
- `onpaste` 粘贴触发

### VUE父子组件渲染
- 加载渲染过程
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
- 子组件更新过程
父beforeUpdate->子beforeUpdate->子updated->父updated
- 父组件更新过程
父beforeUpdate->父updated
- 销毁过程
父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

### 原型链打印
```js
function Foo() {
    Foo.a = function() {
        console.log(1)
    }
    this.a = function() {
        console.log(2)
    }
}
// 以上只是 Foo 的构建方法，没有产生实例，此刻也没有执行

Foo.prototype.a = function() {
    console.log(3)
}
// 现在在 Foo 上挂载了原型方法 a ，方法输出值为 3

Foo.a = function() {
    console.log(4)
}
// 现在在 Foo 上挂载了直接方法 a ，输出值为 4

Foo.a();
// 立刻执行了 Foo 上的 a 方法，也就是刚刚定义的，所以
// # 输出 4

let obj = new Foo();
/* 这里调用了 Foo 的构建方法。Foo 的构建方法主要做了两件事：
1. 将全局的 Foo 上的直接方法 a 替换为一个输出 1 的方法。
2. 在新对象上挂载直接方法 a ，输出值为 2。
*/

obj.a();
// 因为有直接方法 a ，不需要去访问原型链，所以使用的是构建方法里所定义的 this.a，
// # 输出 2

Foo.a();
// 构建方法里已经替换了全局 Foo 上的 a 方法，所以
// # 输出 1
```